<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>QBrain</title>
		<link rel="stylesheet" href="css/brain.css">
		<script src="js/utils.js"></script>
		<script src="js/models.js"></script>
	</head>
	<body>
		<div class="home-container" onclick="location.href='https://the-second-brain.github.io/';">
			<div class="home_2">QBrain</div>
		</div>
		<img class="info_button" id="info_button" src="images/info.png" alt="Show info">
		<img class="close_button" id="close_button" src="images/close.png" alt="Close info">
		<div class="color-scale-container" id="color-scale-container">
			<div class="color_scale_header">Samverkan</div>
			<div class="color_scale_high">< Hög</div>
			<div class="color_scale_low">< Låg</div>
			<div class="color_scale"></div>
		</div>
		<h1 id='title'></h1>
		<div class='info-demo'>
			<div id='info-container-demo' class='connection-container-demo'>
				<img class="arrow" id="left_button-demo" src="/images/left.png" alt="Left button">
				<h2 id='section_title_pres-demo'></h2>
				<img class="arrow" id="right_button-demo" src="/images/right.png" alt="Right button">
			</div>
			<h3 id='section_title-demo'></h3>
			<p id='section_intro-demo'></p>
		</div>
		<div class='info'>
			
			<h3 id='section_title'></h3>
			<p id='section_intro'></p>
		</div>
		
		<script type="module">
			
		    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0/build/three.module.js';
		    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
		    import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';
		    import { FontLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/FontLoader.js';
		    import { TextGeometry } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/geometries/TextGeometry.js';
		    import { Lensflare, LensflareElement } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/objects/Lensflare.js';
		    
		    const start_color = [255, 5, 5];
		    const end_color = [0, 50, 255];
		    
		    const pres_titles = ["<b style='font-size:24px'>QBrain</b><br><b style='font-size:12px'>Mångdubblar hjärnans kapacitet</b>", "Kubens delar", "Mission", "Handlingsplaner", "Förutsättningar", "Forskning och fakta", "Historik", "Aktuellt", "Individnivå", "Gruppnivå", "Organisationsnivå", "Kopplingar", "Inaktiva områden", "Sätt igång"];
		    const pres_texts = ["QBrain är en AI-baserad lösning för planering, genomförande, utveckling och uppföljning av olika typer av uppdrag. Det kan vara alltifrån ett företags hela verksamhet till olika typer av förändringsarbeten eller mindre projekt inom specifika områden. Systemet utgår ifrån hur vår hjärna fungerar och kompletterar den för att vi skall kunna förverkliga det som är riktigt viktigt.<br><br>QBrain bygger i grunden på de tre stegen som varje uppdrag består av:<br><b style='font-size:20px'>Mission</b> = Hur ser uppdraget ut och vad skall uppnås?<br><b style='font-size:20px'>Aktiviteter</b> = Vad behöver göras för att lyckas med uppdraget?<br><b style='font-size:20px'>Förutsättningar</b> = Vad krävs för att genomföra de aktiviteter som behövs?",
		    					"QBrain består av tre dimensioner varav Planer är den grundläggande som allting utgår ifrån. Varje steg i Planer (Mission – Aktiviteter - Förutsättningar) är kopplade dels till Processer (Fakta - Historik - Aktuella planer) och dels till Personer (Organisation – Grupper - Individer).<br><br>I varje del av kuben finns olika uppgifter som skall genomföras. Det kan vara för en hel organisation, en grupp eller en individ och bestå av att:<ul><li>Ta fram visioner och mål för uppdraget.</li><li>Ta fram strategier och handlingsplaner.</li><li>Analysera förutsättning för att lyckas.</li><li>Utvärdera tidigare uppdrag.</li><li>Använda forskning för att effektivisera uppdraget.</li></ul>Klicka på en del av kuben för mer information om vad som skall göras där.",
		    					"Här arbetar man med en beskrivning av uppdraget och vad som skall uppnås för en organisation, grupp eller individ. Utifrån fakta och forskning och tidigare genomförda liknande uppdrag tas ett nytt uppdrag fram.<br><br>Det kan exempelvis handla om att definiera:<ul><li>Affärsidé</li><li>Verksamhetsidé</li><li>Projektidé</li><li>Visioner</li><li>Övergripande mål</li></ul>",
		    					"Här upprättas konkreta handlingsplaner för vad som ska göras för att uppnå målen. Det är viktigt att handlingsplanerna är realistiska med tanke på förutsättningarna samt att de är baserade på fakta, analyser av liknande företeelser och lärdomar av tidigare stadier.<br><br>Handlingsplanerna kan vara konkreta planer för vad som ska göras den närmaste tiden eller mer övergripande strategier och åtgärdsplaner.",
		    					"Här analyseras vilka förutsättningar som krävs för att målen ska uppnås och utvärderas vilka förutsättningar som finns för tillfället. Det kan handla om förutsättningar gällande:<ul><li>Marknaden</li><li>Konkurrenter</li><li>Kompetens</li><li>Tidsaspekter</li><li>Lokaler</li><li>Ekonomi</li><li>Kultur</li><li>Personliga egenskaper</li></ul>",
		    					"Här samlas fakta och forskning som beslutsunderlag för utformningen av förutsättningar, mål och handlingsplaner. Det kan vara:<ul><li>Internutbildningar</li><li>Marknadsanalyser</li><li>Expertråd</li><li>Organisationsmodeller</li><li>Workshops</li><li>Forskningsrapporter</li><li>Medarbetarundersökningar</li></ul>",
		    					"Ett projekt bygger som regel på en iterativ process där tidiga versioner ersätts av mer utvecklade, komplexa eller förfinade versioner. På den här nivån finns arkiverade versioner av projektet som har eller ska utvärderas och analyseras, exempelvis genom användartestning, kundundersökningar eller SWOT-analys.<ul><li>Vad har inte fungerat och varför?</li><li>Vilka styrkor kan bibehållas?</li><li>Vilka svagheter behöver förbättras?</li><li>Vilka funktioner eller kompetenser saknas?</li>",
		    					"Här sker det största arbetet. Aktuella förutsättningar, handlingsplaner och mål uppdateras och revideras i takt med projektets framsteg eller motgångar. Om förutsättningarna förändras behöver ofta mål och handlingsplaner anpassas efter de nya förutsättningarna. Samtidigt ska arbetet på den här nivån anpassas efter forskning, fakta och analyser av tidigare stadier i projektet.<br><br>The Second Brain väver samman dessa avvägningar. Alla perspektiv tas i beaktande och eventuella brister synliggörs.<br><br>När en version av projektet inte längre är aktuell kan den utvärderas och analyseras för att sedan arkiveras till Historiken.",
		    					"På den här nivån uppmärksammas varje individ. Vilka kompetenser finns och vilka saknas? Hur ska varje enskild individ arbeta för att uppnå både personliga och mer övergripande målsättningar?",
		    					"Här analyseras projektet på gruppnivå. Hur arbetas det på gruppnivå och vilken funktion fyller gruppen? Vilka grupper samverkar med varandra och hur? Gruppens arbete måste var anpassat efter individuella förutsättningar och samtidigt sträva efter att uppnå övergripande målsättningar.<br><br>En grupp kan till exempel vara:<ul><li>Dotterbolag</li><li>Avdelning</li><li>Team</li><li>Årskull</li><li>Ledningsgrupp</li></ul>",
		    					"På den här nivån definieras de övegripande målen och visionerna. Här sker också det övergripande strategiska arbetet.<br><br>Mål och strategier ska genomsyra arbetet på lägre nivåer samtidigt som de behöver anpassas efter aktuella förusättningar för att vara realistisika och genomförbara.",
		    					"Projektets områden samverkar med varandra på olika sätt och över flera nivåer. The Second Brain hanterar områden som är nära kopplade till varandra och ger möjlighet att bedöma hur väl kopplade områden fungerar tillsammans.<br><br>Områden som samverkar väl markeras med blått och områden som inte fungerar tillsammans med andra markeras med rött.<br><br>Röd färg indikerar att området kräver mer arbete eller att kopplade områden behöver förändras.",
		    					"Områden som inte är relevanta för projektet kan inaktiveras. Ett helt nytt projekt har till exempel sällan någon Historik och i ett enmansprojekt är troligtvis varken Grupp- eller Organisationsnivån relevant.",
		    					'The Second Brain Cube är en digital lösning för planering, genomförande, utveckling och uppföljning av alla stadier i ett projekt. Det är ett kraftfullt verktyg som strukturerar komplexa saker på tydliga sätt.<br><br>The Second Brain fungerar i många olika sammanhang eftersom liknande strukturer och mekanismer ligger till grund för att ett mål ska uppnås.<br><br>Ett lämpligt första steg är att definiera projektets mål och visioner på kort och lång sikt. Stäng guiden, dubbelklicka på området "Målsättningar på organisationsnivå" och lägg till en artikel kring projektets mål och visioner.'];
		    
		    const scene = new THREE.Scene();
		    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		    const renderer = new THREE.WebGLRenderer( { antialias: true } );
		    const geometry = new THREE.BoxGeometry();
		    const textureLoader = new THREE.TextureLoader();
			const textureFlare0 = textureLoader.load( 'images/lensflare0.png' );
			const textureFlare3 = textureLoader.load( 'images/lensflare3.png' );
			
			localStorage.setItem("time", JSON.stringify(Date.now() * 0.0001));
		    
		    let cubes = JSON.parse(localStorage.getItem("cubes"));
		    let current_cube;
		    for (let i = 0; i < cubes.length; i++) {
				if(cubes[i].id == localStorage.getItem("current_cube")) {
					current_cube = cubes[i];
				}
			}
			document.getElementById("title").innerHTML = current_cube.title;
			if (parseInt(localStorage.getItem("pres_idx")) >= 0) {
				current_cube = JSON.parse(localStorage.getItem("pres_cube"));
				showPresentation(parseInt(localStorage.getItem("pres_idx")), current_cube);
				document.getElementById("close_button").style.display = "block";
				document.getElementById("info_button").style.display = "none";
			} else {
				document.getElementById("info_button").style.display = "block";
			}
			
		    const controls = new OrbitControls( camera, renderer.domElement );
		    const gltfLoader = new GLTFLoader();
		    
		    const color = 0xFFFFFF;
		    const intensity = 1;
		    const light = new THREE.DirectionalLight(color, intensity);
		    light.position.set(-1, 2, 4);
		    scene.add(light);	
		    scene.add( new THREE.AmbientLight( 0xffffff, 0.4 ) );
			
		    let objects = [];
		    let secs = current_cube.sections;
		    for (let pos = 0; pos < secs.length; pos++) {
		    	const cube_color = getColor(current_cube, secs[pos]);
		    	const material = new THREE.MeshPhongMaterial( cube_color );
		    	const cube = new THREE.Mesh( geometry, material );
		    	let x = 1;
		    	let y = 1;
		    	let z = 1;
		    	if (pos % 3 == 0) {
					x = -1;
				} else if (pos % 3 == 1) {
					x = 0;
				}
				if (Math.floor(pos / 3) % 3 == 0) {
					y = -1;
				} else if (Math.floor(pos / 3) % 3 == 1) {
					y = 0;
				}
				if (Math.floor(pos / 9) == 0) {
					z = -1;
				} else if (Math.floor(pos / 9) == 1) {
					z = 0;
				}
				const gap = 1.25;
				cube.position.set( x * gap, y * gap, z * gap );
				cube.material.transparent = true;
		    	cube.material.opacity = 0.85; 
		    	if(!secs[pos].active) {
		    		cube.material.opacity = 0.4; 
		    	}
		    	cube.userData = {
                	id: secs[pos].id,
                	title: secs[pos].title,
                	intro: secs[pos].intro,
                	active: secs[pos].active,
                	strength: getStrength(current_cube, secs[pos])
            	};
            	scene.add( cube );
            	objects.push(cube);
		    }
		    
		    if(camera.position.x == 0) {
		    	camera.position.set(4.2,3.2,4.2);
		    }
		    camera.lookAt(new THREE.Vector3(0,0,0)); 
		    let raycaster = new THREE.Raycaster();
		    let mouse = new THREE.Vector2();
		    renderer.setPixelRatio(window.devicePixelRatio);
		    
		    renderer.setSize( window.innerWidth, window.innerHeight );
		    document.body.appendChild( renderer.domElement );

			window.addEventListener( 'resize', onWindowResize );
		    
		    document.addEventListener( 'dblclick', onDocumentDoubleClicked, false );
		    document.addEventListener("mousedown", onMouseDown);
		    document.getElementById("info_button").addEventListener("click", openInfo);
		    document.getElementById("close_button").addEventListener("click", closeInfo);
		    
		    document.getElementById("left_button-demo").addEventListener('click', (() => {
		    	let idx = parseInt(localStorage.getItem("pres_idx"));
				if(idx == 0) {
					idx = pres_texts.length - 1;
				} else {
					idx -= 1;
				}
				localStorage.setItem("pres_idx", idx + "");
				location.reload();
			}));
			
			document.getElementById("right_button-demo").addEventListener('click', (() => {
				let idx = parseInt(localStorage.getItem("pres_idx"));
				idx = (idx + 1) % pres_texts.length;
				localStorage.setItem("pres_idx", idx + "");
				location.reload();
			}));
		    
		    function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function addLight( h, s, l, x, y, z ) {

				const light = new THREE.PointLight( 0xffffff, 1.5, 2000 );
				light.color.setHSL( h, s, l );
				light.position.set( x, y, z );
				scene.add( light );

				const lensflare = new Lensflare();
				lensflare.addElement( new LensflareElement( textureFlare0, 700, 0, light.color ) );
				lensflare.addElement( new LensflareElement( textureFlare3, 60, 0.6 ) );
				lensflare.addElement( new LensflareElement( textureFlare3, 70, 0.7 ) );
				lensflare.addElement( new LensflareElement( textureFlare3, 120, 0.9 ) );
				lensflare.addElement( new LensflareElement( textureFlare3, 70, 1 ) );
				light.add( lensflare );

			}
			
			function onDocumentDoubleClicked(event) {
				if (parseInt(localStorage.getItem("pres_idx")) < 0) {
					event.preventDefault();
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
					raycaster.setFromCamera( mouse, camera );
					var intersects = raycaster.intersectObjects( objects );
					if (intersects.length > 0) {
		    			localStorage.setItem('current_section', intersects[0].object.userData.id);
		    			window.location.href = "section";
					}
    			}
			}
			
			function onMouseDown(event) {
    			event.preventDefault();
    			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    			raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( objects );
				for (let i = 0; i < objects.length; i++) {
					let opacity;
					if(objects[i].userData.active) {
						opacity = 0.85;
					} else {
						opacity = 0.4;
					}
    				const material = new THREE.MeshPhongMaterial( { color: "#ff0000" } );
    				material.color = objects[i].material.color;
    				material.transparent = true;
    				material.opacity = opacity; 
    				objects[i].material = material;
    			}
    			if (intersects.length > 0) {
        			document.getElementById("section_title").innerHTML = intersects[0].object.userData.title;
        			document.getElementById("section_intro").innerHTML = intersects[0].object.userData.intro;
        			intersects[0].object.material.opacity = 1; 
        			if (parseInt(localStorage.getItem("pres_idx")) < 0) {
		    			if(intersects[0].object.userData.active) {
		    				intersects[0].object.material.emissive = intersects[0].object.material.color; 
		    				document.getElementById("section_title").innerHTML += " (" + intersects[0].object.userData.strength + "&nbsp%)";
		    			} else {
		    				document.getElementById("section_title").innerHTML += " (Inaktiv)";
		    				intersects[0].object.material.opacity = 0.7; 
		    			};
        			}
    			}
			}

			function openInfo(event) {
    			event.preventDefault();
				if (parseInt(localStorage.getItem("pres_idx")) < 0) {
					localStorage.setItem("pres_idx", "0");
					let pres_cube = new_std_cube("");
					for (let i = 0; i < pres_cube.sections.length; i++) {
						let connections = getSectionConnections(pres_cube, pres_cube.sections[i].id);
						for (let j = 0; j < connections.length; j++) {
							connections[j].strength = 100;
						}
					}
					localStorage.setItem("pres_cube", JSON.stringify(pres_cube));
					location.reload();
				}
			}
			
			function closeInfo(event) {
    			event.preventDefault();
				localStorage.setItem("pres_idx", "-1");
				location.reload();
			}
			
			function showPresentation(idx, cube) {
				let title = "Guide (";
				document.getElementById("left_button-demo").style.display = "block";
				document.getElementById("right_button-demo").style.display = "block";
				document.getElementById("info-container-demo").style.alignItems = "center";
				document.getElementById("info-container-demo").style.justifyContent = "center";
				document.getElementById("section_title_pres-demo").style.textAlign = "center";
				document.getElementById("section_title_pres-demo").style.textAlign = "center";
				document.getElementById("section_title_pres-demo").style.width = "200px";
				document.getElementById("section_title_pres-demo").innerHTML = pres_titles[idx];
				document.getElementById("section_intro-demo").innerHTML = pres_texts[idx];
				
				var loader = new FontLoader();
				var txt_mat = new THREE.MeshPhongMaterial({color:0xffffff});
				
				title += (idx + 1) + "";
				switch (idx) {
					case 0:
						camera.position.set(5.5,2.5,5.5);
						addLight( 0.59, 0.8, 0.5,-5, 7, -20 );
						loader.load('https://cdn.skypack.dev/three@0.136.0/examples/fonts/droid/droid_sans_bold.typeface.json',function(font) {
						let big_text_settings = {
							font: font,
							size: 0.28,
							height: 0.03,
							curveSegments: 12,
							bevelEnabled: false,
							bevelThickness: 0.1,
							bevelSize: 0.1,
							bevelSegments: 0.1
						};
						let small_text_settings = {
							font: font,
							size: 0.2,
							height: 0.03,
							curveSegments: 12,
							bevelEnabled: false,
							bevelThickness: 0.1,
							bevelSize: 0.1,
							bevelSegments: 0.1
						};
						var plans = new THREE.Mesh(new TextGeometry( 'Planer', big_text_settings ), txt_mat);
						plans.position.z = 0.93;
						plans.position.y = 1;
						plans.position.x = 0.06;
						plans.rotation.set(0, Math.PI/4, 0);
						objects[26].add(plans);
						
						var mission = new THREE.Mesh(new TextGeometry( 'Mission', small_text_settings ), txt_mat);
						mission.position.z = 0.85;
						mission.position.y = -0.05;
						mission.position.x = 0.14;
						mission.rotation.set(0, Math.PI/4, 0);
						objects[26].add(mission);
						
						var activities = new THREE.Mesh(new TextGeometry( 'Aktiviteter', small_text_settings ), txt_mat);
						activities.position.z = 1;
						activities.position.y = -1.25;
						activities.position.x = 0;
						activities.rotation.set(0, Math.PI/4, 0);
						objects[26].add(activities);
						
						var conditions = new THREE.Mesh(new TextGeometry( 'Förutsättningar', small_text_settings ), txt_mat);
						conditions.position.z = 1.25;
						conditions.position.y = -2.45;
						conditions.position.x = -0.25;
						conditions.rotation.set(0, Math.PI/4, 0);
						objects[26].add(conditions);
						} );
					break;
					case 1:
						camera.position.set(6.5,2.5,6.5);
						addLight( 0.59, 0.8, 0.5,-5, 7, -20 );
						loader.load('https://cdn.skypack.dev/three@0.136.0/examples/fonts/droid/droid_sans_bold.typeface.json',function(font) {
						let big_text_settings = {
							font: font,
							size: 0.28,
							height: 0.03,
							curveSegments: 12,
							bevelEnabled: false,
							bevelThickness: 0.1,
							bevelSize: 0.1,
							bevelSegments: 0.1
						};
						let small_text_settings = {
							font: font,
							size: 0.2,
							height: 0.03,
							curveSegments: 12,
							bevelEnabled: false,
							bevelThickness: 0.1,
							bevelSize: 0.1,
							bevelSegments: 0.1
						};
						var plans = new THREE.Mesh(new TextGeometry( 'Planer', big_text_settings ), txt_mat);
						plans.position.z = 0.93;
						plans.position.y = 1;
						plans.position.x = 0.06;
						plans.rotation.set(0, Math.PI/4, 0);
						objects[26].add(plans);
						
						var mission = new THREE.Mesh(new TextGeometry( 'Mission', small_text_settings ), txt_mat);
						mission.position.z = 0.85;
						mission.position.y = -0.05;
						mission.position.x = 0.14;
						mission.rotation.set(0, Math.PI/4, 0);
						objects[26].add(mission);
						
						var activities = new THREE.Mesh(new TextGeometry( 'Aktiviteter', small_text_settings ), txt_mat);
						activities.position.z = 1;
						activities.position.y = -1.25;
						activities.position.x = 0;
						activities.rotation.set(0, Math.PI/4, 0);
						objects[26].add(activities);
						
						var conditions = new THREE.Mesh(new TextGeometry( 'Förutsättningar', small_text_settings ), txt_mat);
						conditions.position.z = 1.25;
						conditions.position.y = -2.45;
						conditions.position.x = -0.25;
						conditions.rotation.set(0, Math.PI/4, 0);
						objects[26].add(conditions);
						
						var processes = new THREE.Mesh(new TextGeometry( 'Processer', big_text_settings ), txt_mat);
						processes.position.z = 3.23;
						processes.position.y = -1.6;
						processes.position.x = -2.26;
						processes.rotation.set(0, Math.PI/4, 0);
						objects[26].add(processes);
						
						var facts = new THREE.Mesh(new TextGeometry( 'Fakta', small_text_settings ), txt_mat);
						facts.position.z = 2.63;
						facts.position.y = -2.13;
						facts.position.x = -1.66;
						facts.rotation.set(0, Math.PI/4, 0);
						objects[26].add(facts);
						
						var history = new THREE.Mesh(new TextGeometry( 'Historik', small_text_settings ), txt_mat);
						history.position.z = 2.43;
						history.position.y = -2.55;
						history.position.x = -1.46;
						history.rotation.set(0, Math.PI/4, 0);
						objects[26].add(history);
						
						var current_plans = new THREE.Mesh(new TextGeometry( 'Aktuella planer', small_text_settings ), txt_mat);
						current_plans.position.z = 2.32;
						current_plans.position.y = -3;
						current_plans.position.x = -1.35;
						current_plans.rotation.set(0, Math.PI/4, 0);
						objects[26].add(current_plans);
						
						var people = new THREE.Mesh(new TextGeometry( 'Personer', big_text_settings ), txt_mat);
						people.position.z = -1.06;
						people.position.y = -1.6;
						people.position.x = 2.03;
						people.rotation.set(0, Math.PI/4, 0);
						objects[26].add(people);
						
						var individuals = new THREE.Mesh(new TextGeometry( 'Individer', small_text_settings ), txt_mat);
						individuals.position.z = -0.96;
						individuals.position.y = -2.13;
						individuals.position.x = 1.93;
						individuals.rotation.set(0, Math.PI/4, 0);
						objects[26].add(individuals);
						
						var groups = new THREE.Mesh(new TextGeometry( 'Grupper', small_text_settings ), txt_mat);
						groups.position.z = -0.66;
						groups.position.y = -2.55;
						groups.position.x = 1.63;
						groups.rotation.set(0, Math.PI/4, 0);
						objects[26].add(groups);
						
						var organisation = new THREE.Mesh(new TextGeometry( 'Organisation', small_text_settings ), txt_mat);
						organisation.position.z = -0.12;
						organisation.position.y = -3;
						organisation.position.x = 1.09;
						organisation.rotation.set(0, Math.PI/4, 0);
						objects[26].add(organisation);
						} );
					break;
					case 2:
						camera.position.set(6.5,2.5,6.5);
						addLight( 0.59, 0.8, 0.5,-5, 7, -20 );
						loader.load('https://cdn.skypack.dev/three@0.136.0/examples/fonts/droid/droid_sans_bold.typeface.json',function(font) {
						let big_text_settings = {
							font: font,
							size: 0.28,
							height: 0.03,
							curveSegments: 12,
							bevelEnabled: false,
							bevelThickness: 0.1,
							bevelSize: 0.1,
							bevelSegments: 0.1
						};
						let small_text_settings = {
							font: font,
							size: 0.2,
							height: 0.03,
							curveSegments: 12,
							bevelEnabled: false,
							bevelThickness: 0.1,
							bevelSize: 0.1,
							bevelSegments: 0.1
						};
						var plans = new THREE.Mesh(new TextGeometry( 'Planer', big_text_settings ), txt_mat);
						plans.position.z = 0.93;
						plans.position.y = 1;
						plans.position.x = 0.06;
						plans.rotation.set(0, Math.PI/4, 0);
						objects[26].add(plans);
						
						var mission = new THREE.Mesh(new TextGeometry( 'Mission', small_text_settings ), txt_mat);
						mission.position.z = 0.85;
						mission.position.y = -0.05;
						mission.position.x = 0.14;
						mission.rotation.set(0, Math.PI/4, 0);
						objects[26].add(mission);
						
						var processes = new THREE.Mesh(new TextGeometry( 'Processer', big_text_settings ), txt_mat);
						processes.position.z = 3.23;
						processes.position.y = -1.6;
						processes.position.x = -2.26;
						processes.rotation.set(0, Math.PI/4, 0);
						objects[26].add(processes);
						
						var facts = new THREE.Mesh(new TextGeometry( 'Fakta', small_text_settings ), txt_mat);
						facts.position.z = 2.63;
						facts.position.y = -2.13;
						facts.position.x = -1.66;
						facts.rotation.set(0, Math.PI/4, 0);
						objects[26].add(facts);
						
						var history = new THREE.Mesh(new TextGeometry( 'Historik', small_text_settings ), txt_mat);
						history.position.z = 2.43;
						history.position.y = -2.55;
						history.position.x = -1.46;
						history.rotation.set(0, Math.PI/4, 0);
						objects[26].add(history);
						
						var current_plans = new THREE.Mesh(new TextGeometry( 'Aktuella planer', small_text_settings ), txt_mat);
						current_plans.position.z = 2.32;
						current_plans.position.y = -3;
						current_plans.position.x = -1.35;
						current_plans.rotation.set(0, Math.PI/4, 0);
						objects[26].add(current_plans);
						
						var people = new THREE.Mesh(new TextGeometry( 'Personer', big_text_settings ), txt_mat);
						people.position.z = -1.06;
						people.position.y = -1.6;
						people.position.x = 2.03;
						people.rotation.set(0, Math.PI/4, 0);
						objects[26].add(people);
						
						var individuals = new THREE.Mesh(new TextGeometry( 'Individer', small_text_settings ), txt_mat);
						individuals.position.z = -0.96;
						individuals.position.y = -2.13;
						individuals.position.x = 1.93;
						individuals.rotation.set(0, Math.PI/4, 0);
						objects[26].add(individuals);
						
						var groups = new THREE.Mesh(new TextGeometry( 'Grupper', small_text_settings ), txt_mat);
						groups.position.z = -0.66;
						groups.position.y = -2.55;
						groups.position.x = 1.63;
						groups.rotation.set(0, Math.PI/4, 0);
						objects[26].add(groups);
						
						var organisation = new THREE.Mesh(new TextGeometry( 'Organisation', small_text_settings ), txt_mat);
						organisation.position.z = -0.12;
						organisation.position.y = -3;
						organisation.position.x = 1.09;
						organisation.rotation.set(0, Math.PI/4, 0);
						objects[26].add(organisation);
						} );
						for (let i = 0; i < cube.sections.length; i++) {
							if(Math.floor(i / 3) % 3 == 2) {
								cube.sections[i].active = 1;
							} else {
								cube.sections[i].active = 0;
							}
						}
					break;
					case 3:
						for (let i = 0; i < cube.sections.length; i++) {
							if(Math.floor(i / 3) % 3 == 1) {
								cube.sections[i].active = 1;
							} else {
								cube.sections[i].active = 0;
							}
						}
					break;
					case 4:
						for (let i = 0; i < cube.sections.length; i++) {
							if(Math.floor(i / 3) % 3 == 0) {
								cube.sections[i].active = 1;
							} else {
								cube.sections[i].active = 0;
							}
						}
					break;
					case 5:
						for (let i = 0; i < cube.sections.length; i++) {
							if(i % 3 == 0) {
								cube.sections[i].active = 1;
							} else {
								cube.sections[i].active = 0;
							}
						}
					break;
					case 6:
						for (let i = 0; i < cube.sections.length; i++) {
							if(i % 3 == 1) {
								cube.sections[i].active = 1;
							} else {
								cube.sections[i].active = 0;
							}
						}
					break;
					case 7:
						for (let i = 0; i < cube.sections.length; i++) {
							if(i % 3 == 2) {
								cube.sections[i].active = 1;
							} else {
								cube.sections[i].active = 0;
							}
						}
					break;
					case 8:
						for (let i = 0; i < cube.sections.length; i++) {
							if(Math.floor(i / 9) == 0) {
								cube.sections[i].active = 1;
							} else {
								cube.sections[i].active = 0;
							}
						}
					break;
					case 9:
						for (let i = 0; i < cube.sections.length; i++) {
							if(Math.floor(i / 9) == 1) {
								cube.sections[i].active = 1;
							} else {
								cube.sections[i].active = 0;
							}
						}
					break;
					case 10:
						for (let i = 0; i < cube.sections.length; i++) {
							if(Math.floor(i / 9) == 2) {
								cube.sections[i].active = 1;
							} else {
								cube.sections[i].active = 0;
							}
						}
					break;
					case 11:
						for (let i = 0; i < cube.sections.length; i++) {
						let connections = getSectionConnections(cube, cube.sections[i].id)
							for (let j = 0; j < connections.length; j++) {
								if(Math.random() < 0.5) {
									connections[j].strength = 0;
								} else {
									connections[j].strength = 100;
								}
							}
						}
						document.getElementById("color-scale-container").style.display = "block";
					break;
					case 12:
						for (let i = 0; i < cube.sections.length; i++) {
							let connections = getSectionConnections(cube, cube.sections[i].id);
							for (let j = 0; j < connections.length; j++) {
								if(Math.random() < 0.5) {
									connections[j].strength = 0;
								} else {
									connections[j].strength = 100;
								}
							}
						}
						for (let i = 0; i < cube.sections.length; i++) {
							if(Math.floor(i / 9) == 0) {
								cube.sections[i].active = 1;
							} else {
								cube.sections[i].active = 0;
							}
						}
					break;
					case 13:
						for (let i = 0; i < cube.sections.length; i++) {
							if(i == 26) {
								cube.sections[i].active = 1;
							} else {
								cube.sections[i].active = 0;
							}
						}
					break;
				}
				title += "/" + pres_texts.length + ")";
				document.getElementById("title").innerHTML = title;
			}
			
			function restore_active() {
				let active_list = JSON.parse(localStorage.getItem("active_list"));
				let cube;
				let cubes = JSON.parse(localStorage.getItem("cubes"));
				for (let i = 0; i < cubes.length; i++) {
					if(cubes[i].id == localStorage.getItem("current_cube")) {
						cube = cubes[i];
					}
				}
				for (let i = 0; i < cube.sections.length; i++) {
					cube.sections[i].active = active_list[i];
				}
				localStorage.setItem("cubes", JSON.stringify(cubes));
				localStorage.setItem("pres_idx", "-1");
				location.reload();
			}
			
			function getColor(cube, section) {
				if(!section.active) {
					return {color: "#333"}
				}
				let strength = getStrength(cube, section);
				let r, g;
				let b = "00";
				if(strength <= 50) {
					r = "ff";
					g = (255 * strength) / 50;
					g = Math.round(g).toString(16);
					if(g.length == 1) {
						g = "0" + g;
					}
				} else {
					g = "ff";
					r = (255 * (100 - strength)) / 50;
					r = Math.round(r).toString(16);
					b = (50 * (strength - 50)) / 50;
					b = Math.round(b).toString(16);
					if(r.length == 1) {
						r = "0" + r;
					}
					if(b.length == 1) {
						b = "0" + b;
					}
				}
				
				let rr = Math.round(start_color[0] + ((end_color[0] - start_color[0]) / 100) * strength).toString(16);
				if(rr.length == 1) {
					rr = "0" + rr;
				}
				let gg = Math.round(start_color[1] + ((end_color[1] - start_color[1]) / 100) * strength).toString(16);
				if(gg.length == 1) {
					gg = "0" + gg;
				}
				let bb = Math.round(start_color[2] + ((end_color[2] - start_color[2]) / 100) * strength).toString(16);
				if(bb.length == 1) {
					bb = "0" + bb;
				}
				
				let colorString = "#" + r + g + b;
				colorString = "#" + rr + gg + bb;
				return {color: colorString};
			}
			
			function render() {
				const time = parseInt(localStorage.getItem("time"));
				const timer = Date.now() * 0.0001;
				scene.traverse( function ( object ) {
					if ( object.isMesh === true ) {
						object.rotation.x = timer * 5;
						object.rotation.y = timer * 2.5;
						object.position.x = object.position.x + (timer - time)*0.01;
					}
				} );

				renderer.render( scene, camera );

			}


		    function animate() {
		        requestAnimationFrame( animate );
		        renderer.render( scene, camera );
		    }
		    animate();

		</script>
	</body>
</html>
